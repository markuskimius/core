#!/usr/bin/env bash

##############################################################################
# CORE: Essential unix utilities
# https://github.com/markuskimius/core
#
# Copyright (c)2020-2024 Mark Kim
# Released under GNU General Public License version 2.
# https://github.com/markuskimius/core/blob/main/LICENSE
##############################################################################

function usage() {
    cat <<EOF
Control jobs.

Usage: ${SCRIPTNAME} COMMAND [JOBNAME]

COMMAND:
  list                  List the job.
  stop                  Stop the job.
  start                 Start the job.
  restart               Restar the job.
  crontab               Show the crontab entry for the job.

The jobs may be configured by editing a file the matches the pattern
"${DPM}/*/etc/core-job.csv".  The file processed via core-doc.sh.

EOF
}


##############################################################################
# PROGRAM BEGINS HERE

source "getopt.sh" || exit 1
source "core-cfg.sh" || exit 1

SCRIPTPATH=$BASH_SOURCE
SCRIPTNAME=$(basename -- "$BASH_SOURCE")
CORK=${CORK-${HOME}/work}
TORK=${CORK}/token
LORK=${CORK}/log

declare -A PROCS=()


function main() {
    local OPTOPT OPTARG
    local cmd
    local arg

    # Process options
    while getopt-sh "h" "help" "$@"; do
        case "$OPTOPT" in
            -h|--help)  usage && exit 0 ;;
            *)          exitcode=1      ;;
        esac
    done
    cmd=${OPTARG[0]}
    OPTARG=( "${OPTARG[@]:1}" )

    # Sanity check
    if [[ -z "$cmd" ]]; then
        printf "COMMAND required\n\n" 1>&2
        exitcode=1
    fi

    if (( exitcode )); then
        usage 1>&2
        exit $exitcode
    fi

    # Execute command
    for arg in "${OPTARG[@]-*}"; do
        case "$cmd" in
            list)    job-list    "$arg" ;;
            stop)    job-stop    "$arg" ;;
            start)   job-start   "$arg" ;;
            restart) job-restart "$arg" ;;
            crontab) job-crontab "$arg" ;;
            *)       printf "%s: Invalid command\n" "${cmd}" && exit 1;;
        esac
    done
}


function job-stop() {
    local -a params=( name cmdline )
    local -a jobs=()
    local name=${1-*}
    local line
    local i

    # Validate
    [[ -z "$name" ]] && return 1;

    # Get all matching jobs
    while IFS= read -r line; do
        jobs+=( "$line" )
    done < <(core-cfg -d $'\n' -f '"${rec[name]}" == $name' core-job.csv "${params[@]}")

    # Sanity check
    if (( ${#jobs[@]} == 0 )); then
        printf "%s: No such job\n" "$name" 1>&2
        return 1
    fi

    cache-pids

    # Kill running jobs
    for((i=0; i<${#jobs[@]}; i+=${#params[@]})); do
        local -a job=( "${jobs[@]:i:${#params[@]}}" )
        local jobname=${job[0]}
        local jobcmd=${job[1]}
        local pids=( $(get-pids "${jobcmd}") )

        if (( ${#pids[@]} )); then
            local pid

            printf "Stopping %s (%s)...\n" "${jobname}" "${pids[*]}"
            for pid in "${pids[@]}"; do
                kill "$pid"
            done
        else
            printf "%s is not running\n" "${jobname}"
        fi
    done

    return 0
}


function job-start() {
    local -a params=( name cmdline )
    local -a jobs=()
    local name=${1-*}
    local line
    local i

    # Validate
    [[ -z "$name" ]] && return 1;

    # Get all matching jobs
    while IFS= read -r line; do
        jobs+=( "$line" )
    done < <(core-cfg -d $'\n' -f '"${rec[name]}" == $name' core-job.csv "${params[@]}")

    # Sanity check
    if (( ${#jobs[@]} == 0 )); then
        printf "%s: No such job\n" "$name" 1>&2
        return 1
    fi

    cache-pids

    # Output
    for((i=0; i<${#jobs[@]}; i+=${#params[@]})); do
        local -a job=( "${jobs[@]:i:${#params[@]}}" )
        local jobname=${job[0]}
        local jobcmd=${job[1]}
        local pids=$(get-pids "${jobcmd}")

        if [[ -n "$pids" ]]; then
            printf "%s already running as pid(s) %s\n" "$jobname" "$pids"
        else
            local tok="${TORK}/${jobname}.token"
            local log="${LORK}/${jobname}_$(date "+%Y%m%d_%H:%M:%S").log"

            printf "Starting %s ...\n" "${jobname}"
            (
                touch "$tok" \
                && eval "${jobcmd}" \
                && rm -f "$tok"
            ) 2>&1 | tee "$log"
        fi
    done

    return 0
}


function job-restart() {
    job-stop "$@" && PROCS=() && job-start "$@"
}


function job-list() {
    local -a params=( name cmdline start stop )
    local -a jobs=()
    local format="%-15s %-15s %-15s %-15s %s"
    local name=${1-*}
    local line
    local i

    # Validate
    [[ -z "$name" ]] && return 1;

    # Get all matching jobs
    while IFS= read -r line; do
        jobs+=( "$line" )
    done < <(core-cfg -d $'\n' -f '"${rec[name]}" == $name' core-job.csv "${params[@]}")

    # Output
    printf "${format}\n" NAME START STOP STATUS COMMAND

    cache-pids

    for((i=0; i<${#jobs[@]}; i+=${#params[@]})); do
        local -a job=( "${jobs[@]:i:${#params[@]}}" )
        local jobname=${job[0]}
        local jobcmd=${job[1]}
        local pids=$(get-pids "${jobcmd}")
        local tok="${TORK}/${jobname}.token"
        local status

        if [[ -n "$pids" ]]; then
            status="${pids}"
        elif [[ -f "$tok" ]]; then
            status="ERROR"
        else
            status="OK"
        fi

        printf "${format}\n" "$jobname" "${job[2]}" "${job[3]}" "$status" "$jobcmd"
    done
}


function job-crontab() {
    local -a params=( name cmdline start stop )
    local -a jobs=()
    local name=${1-*}
    local line
    local i

    # Validate
    [[ -z "$name" ]] && return 1;

    # Get all matching jobs
    while IFS= read -r line; do
        jobs+=( "$line" )
    done < <(core-cfg -d $'\n' -f '"${rec[name]}" == $name' core-job.csv "${params[@]}")

    # Output
    for((i=0; i<${#jobs[@]}; i+=${#params[@]})); do
        local -a job=( "${jobs[@]:i:${#params[@]}}" )

        [[ -n "${job[2]}" ]] && printf "%-20s %q %q %q %q\n" "${job[2]}" "$(which bash)" "${SCRIPTNAME}" start "${job[0]}"
        [[ -n "${job[3]}" ]] && printf "%-20s %q %q %q %q\n" "${job[3]}" "$(which bash)" "${SCRIPTNAME}" stop "${job[0]}"
    done
}


function get-pids() {
    printf "%s\n" "${PROCS[${1}]:1}"
}


function cache-pids() {
    if (( ${#PROCS[@]} == 0 )); then
        local -a pids=()
        local line
        local pid
        local cmd

        shopt -s extglob

        while IFS= read -r line; do
            line=${line##+( )}
            pid=${line%% *}
            cmd=${line#* }

            PROCS[${cmd}]+=" $pid"
        done < <("$(command -v procps || echo ps)" ax -o pid,command)
    fi
}


##############################################################################
# ENTRY POINT

main "$@"


# vim:ft=bash
